# Copyright 2023 Canonical Ltd.
# See LICENSE file for licensing details.

"""Cluster topology changes observer."""

import json
import subprocess
import sys
from asyncio import as_completed, get_running_loop, run, wait
from contextlib import suppress
from os import environ
from ssl import create_default_context
from time import sleep
from urllib.parse import urljoin
from urllib.request import urlopen

import yaml

API_REQUEST_TIMEOUT = 5
PATRONI_CLUSTER_STATUS_ENDPOINT = "cluster"
TLS_CA_BUNDLE_FILE = "peer_ca_bundle.pem"
SNAP_CURRENT_PATH = "/var/snap/charmed-postgresql/current"
SNAP_CONF_PATH = f"{SNAP_CURRENT_PATH}/etc"
PATRONI_CONF_PATH = f"{SNAP_CONF_PATH}/patroni"

# File path for the spawned cluster topology observer process to write logs.
LOG_FILE_PATH = "/var/log/cluster_topology_observer.log"


class UnreachableUnitsError(Exception):
    """Cannot reach any known cluster member."""


def call_url(url, context):
    """Task handler for calling an url."""
    try:
        # Scheme is generated by the charm
        resp = urlopen(  # noqa: S310
            url,
            timeout=API_REQUEST_TIMEOUT,
            context=context,
        )
        return json.loads(resp.read())
    except Exception as e:
        print(f"Failed to contact {url} with {e}")


def check_for_authorisation_rules_changes(run_cmd, unit, charm_dir, previous_authorisation_rules):
    """Check for changes in the authorisation rules.

    If changes are detected, dispatch an event to handle them.
    """
    # Read contents from the pg_hba.conf file.
    with open("/var/snap/charmed-postgresql/common/var/lib/postgresql/pg_hba.conf") as file:
        current_authorisation_rules = file.read()
        current_authorisation_rules = [
            line for line in current_authorisation_rules.splitlines() if not line.startswith("#")
        ]
    # If it's the first time the authorisation rules were retrieved, then store it and use
    # it for subsequent checks.
    if not previous_authorisation_rules:
        previous_authorisation_rules = current_authorisation_rules
    # If the authorisation rules changed, dispatch a charm event to handle this change.
    elif current_authorisation_rules != previous_authorisation_rules:
        previous_authorisation_rules = current_authorisation_rules
        dispatch(run_cmd, unit, charm_dir, "authorisation_rules_change")
    return previous_authorisation_rules


def check_for_cluster_topology_changes(
    run_cmd, unit, charm_dir, previous_cluster_topology, current_cluster_topology
):
    """Check for changes in the cluster topology.

    If changes are detected, dispatch an event to handle them.
    """
    # If it's the first time the cluster topology was retrieved, then store it and use
    # it for subsequent checks.
    if not previous_cluster_topology:
        previous_cluster_topology = current_cluster_topology
    # If the cluster topology changed, dispatch a charm event to handle this change.
    elif current_cluster_topology != previous_cluster_topology:
        previous_cluster_topology = current_cluster_topology
        dispatch(run_cmd, unit, charm_dir, "cluster_topology_change")
    return previous_cluster_topology


def check_for_database_changes(run_cmd, unit, charm_dir, previous_databases):
    """Check for changes in the databases.

    If changes are detected, dispatch an event to handle them.
    """
    conf_file_path = "/var/snap/charmed-postgresql/current/etc/patroni/patroni.yaml"
    with open(conf_file_path) as conf_file:
        conf_file_contents = yaml.safe_load(conf_file)
        username = conf_file_contents["postgresql"]["authentication"]["superuser"]["username"]
        password = conf_file_contents["postgresql"]["authentication"]["superuser"]["password"]
    env = environ.copy()
    env["PGPASSWORD"] = password
    command = [
        "sudo",
        "-E",
        "-H",
        "-u",
        "_daemon_",
        "charmed-postgresql.patronictl",
        "-c",
        conf_file_path,
        "query",
        "-c",
        "SELECT datname,datacl FROM pg_database;",
        "-U",
        username,
        "-d",
        "postgres",
    ]
    try:
        # Input is generated by the charm
        current_databases = subprocess.check_output(command, env=env)  # noqa: S603
    except subprocess.CalledProcessError as e:
        with open(LOG_FILE_PATH, "a") as log_file:
            log_file.write(f"Failed to retrieve databases: {e}\n")
        return previous_databases
    else:
        # If it's the first time the databases were retrieved, then store it and use
        # it for subsequent checks.
        if not previous_databases:
            previous_databases = current_databases
        # If the databases changed, dispatch a charm event to handle this change.
        elif current_databases != previous_databases:
            previous_databases = current_databases
            dispatch(run_cmd, unit, charm_dir, "databases_change")
        return previous_databases


def dispatch(run_cmd, unit, charm_dir, custom_event):
    """Use the input juju-run command to dispatch a custom event."""
    dispatch_sub_cmd = "JUJU_DISPATCH_PATH=hooks/{} {}/dispatch"
    # Input is generated by the charm
    subprocess.run([run_cmd, "-u", unit, dispatch_sub_cmd.format(custom_event, charm_dir)])  # noqa: S603


async def main():
    """Main watch and dispatch loop.

    Watch the Patroni API cluster info. When changes are detected, dispatch the change event.
    """
    patroni_urls, run_cmd, unit, charm_dir = sys.argv[1:]

    previous_cluster_topology = {}
    previous_authorisation_rules = []
    previous_databases = None
    urls = [urljoin(url, PATRONI_CLUSTER_STATUS_ENDPOINT) for url in patroni_urls.split(",")]
    member_name = unit.replace("/", "-")
    while True:
        # Disable TLS chain verification
        context = create_default_context()
        with suppress(FileNotFoundError):
            context.load_verify_locations(cafile=f"{PATRONI_CONF_PATH}/{TLS_CA_BUNDLE_FILE}")

        cluster_status = None
        loop = get_running_loop()
        tasks = [loop.run_in_executor(None, call_url, url, context) for url in urls]
        for task in as_completed(tasks):
            if result := await task:
                for task in tasks:
                    task.cancel()
                await wait(tasks)
                cluster_status = result
                break
        if not cluster_status:
            raise UnreachableUnitsError("Unable to reach cluster members")
        current_cluster_topology = {}
        urls = []
        is_primary = False
        for member in cluster_status["members"]:
            current_cluster_topology[member["name"]] = member["role"]
            member_url = urljoin(member["api_url"], PATRONI_CLUSTER_STATUS_ENDPOINT)
            # Call the current unit first
            if member["name"] == member_name:
                urls.insert(0, member_url)
                # Check if the current member is the primary.
                if member["role"] == "leader":
                    is_primary = True
            else:
                urls.append(member_url)

        previous_cluster_topology = check_for_cluster_topology_changes(
            run_cmd, unit, charm_dir, previous_cluster_topology, current_cluster_topology
        )

        if is_primary:
            previous_authorisation_rules = check_for_authorisation_rules_changes(
                run_cmd, unit, charm_dir, previous_authorisation_rules
            )
            previous_databases = check_for_database_changes(
                run_cmd, unit, charm_dir, previous_databases
            )

        # Wait some time before checking again for a cluster topology change.
        sleep(30)


if __name__ == "__main__":
    run(main())
